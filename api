import type { VercelRequest, VercelResponse } from '@vercel/node';
import { Client } from '@notionhq/client';

const notion = new Client({ auth: process.env.NOTION_TOKEN });
const PAGE_ID = (process.env.NOTION_PAGE_ID || '').replace(/-/g, '');
const SHARED_TOKEN = process.env.PUBLIC_EDIT_TOKEN || '';
const MAX_CHARS = Number(process.env.MAX_CHARS || 5000);

type Block = any;

async function listAllChildren(blockId: string): Promise<Block[]> {
  const all: Block[] = [];
  let cursor: string | undefined = undefined;
  do {
    const resp = await notion.blocks.children.list({
      block_id: blockId,
      page_size: 100,
      start_cursor: cursor
    });
    all.push(...resp.results);
    cursor = resp.has_more ? (resp.next_cursor || undefined) : undefined;
  } while (cursor);
  return all;
}

function isHeadingText(block: Block, text: string) {
  const t = block?.type;
  if (!t || !block[t]) return false;
  const isHeading = t === 'heading_1' || t === 'heading_2' || t === 'heading_3';
  if (!isHeading) return false;
  const rich = block[t].rich_text || [];
  const content = rich.map((r: any) => r?.plain_text || '').join('');
  return content.trim() === text;
}

function toParagraphBlocks(content: string): Block[] {
  const parts = content
    .replace(/\r/g, '')
    .split(/\n{2,}/)
    .map(s => s.trim())
    .filter(Boolean);
  if (parts.length === 0) {
    return [{
      object: 'block',
      type: 'paragraph',
      paragraph: { rich_text: [{ type: 'text', text: { content: '' } }] }
    }];
  }
  return parts.map(p => ({
    object: 'block',
    type: 'paragraph',
    paragraph: {
      rich_text: [{ type: 'text', text: { content: p.slice(0, 2000) } }]
    }
  }));
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  if (req.method === 'OPTIONS') return res.status(200).end();

  if (req.method !== 'POST') {
    return res.status(405).json({ ok: false, error: 'Use POST' });
  }

  try {
    const { token, content } = (req.body || {}) as { token?: string; content?: string };

    if (!token || token !== SHARED_TOKEN) {
      return res.status(401).json({ ok: false, error: 'Unauthorized' });
    }
    const text = (content || '').toString();
    if (!text) return res.status(400).json({ ok: false, error: 'Empty content' });
    if (text.length > MAX_CHARS) {
      return res.status(413).json({ ok: false, error: `Too long (> ${MAX_CHARS})` });
    }

    if (!PAGE_ID) {
      return res.status(400).json({ ok: false, error: 'Missing NOTION_PAGE_ID' });
    }

    // 1) Pobierz dzieci strony i znajdź markery
    const children = await listAllChildren(PAGE_ID);
    const beginIdx = children.findIndex(b => isHeadingText(b, 'BEGIN PUBLIC EDIT'));
    const endIdx   = children.findIndex(b => isHeadingText(b, 'END PUBLIC EDIT'));

    if (beginIdx === -1 || endIdx === -1 || beginIdx >= endIdx) {
      return res.status(400).json({
        ok: false,
        error: 'Markers not found or wrong order. Add H2: BEGIN PUBLIC EDIT / END PUBLIC EDIT'
      });
    }

    const between = children.slice(beginIdx + 1, endIdx);

    // 2) Usuń (archiwizuj) bloki pomiędzy markerami
    for (const blk of between) {
      try { await notion.blocks.delete({ block_id: (blk as any).id }); } catch {}
    }

    // 3) Dodaj nowe akapity na końcu strony
    await notion.blocks.children.append({
      block_id: PAGE_ID,
      children: toParagraphBlocks(text)
    });

    return res.status(200).json({ ok: true });
  } catch (e: any) {
    return res.status(500).json({ ok: false, error: e?.message || 'Server error' });
  }
}
